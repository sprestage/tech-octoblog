<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Technical Blog]]></title>
  <link href="http://sprestage-tech-blog.herokuapp.com/atom.xml" rel="self"/>
  <link href="http://sprestage-tech-blog.herokuapp.com/"/>
  <updated>2013-12-06T19:06:34-08:00</updated>
  <id>http://sprestage-tech-blog.herokuapp.com/</id>
  <author>
    <name><![CDATA[Susan Prestage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Overcoming my fear of Git through knowledge]]></title>
    <link href="http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/overcoming-my-fear-of-git-through-knowledge/"/>
    <updated>2013-12-06T18:59:42-08:00</updated>
    <id>http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/overcoming-my-fear-of-git-through-knowledge</id>
    <content type="html"><![CDATA[<h2>Getting past my fear of Git</h2>

<p>Git kept scaring me.  Mostly, this fear is based on how wonderfully powerful a tool that Git (and github) can be and my lack of easy comfort with the commands.  So, I&rsquo;ve made a list of my most used commands and any notes I need for use.  This goes a bit long, since as I learned more and more commands, I added more that I was starting to use.  Good luck!</p>

<h2>What is Git</h2>

<h4>Basics</h4>

<p>Git is a version control system, VCS.  Don&rsquo;t think too carefully about the other VCSs you know, like Perforce or Subversion.  Git is much different and trying to compare will likely cause confusion.</p>

<h4>Snapshots, instead of differences</h4>

<p>Most other systems tend to store data as changes to a base version of each file.  Git doesn&rsquo;t think of it&rsquo;s data that way.  Instead, Git thinks of its data more like a set of ssnapshots of a minifilesystem.  And, to be efficient, Git only takes a snapshot of the files that have changed, simply linking to all the other files that have not changed.</p>

<h4>Local</h4>

<p>Most operations you perform with Git will be local. The entire history of your repository will be right there on your machine, which means that diffs and browsing the history of your project is very quick.  This also means that working offline is not a problem.  You simply commit all you like while offline, then push your work up to the remote repository server when you get back to a network connection.</p>

<h4>The Three States of Git</h4>

<h6>1. The Working Directory</h6>

<h6>2. The Staging Area</h6>

<h6>3. The Git Repository</h6>

<p>Git has three main states that your files can reside in: commited, modified, and staged.  Commited means that the data is safely stored in your local repository.  Modified means that you have changed the file, but not yet commited it to your local repository.  Staged means that you have marked a modified file to go into your next commit snapshot.</p>

<ul>
<li><p>Check out the project to bring the files from the git repository into your working directory.</p></li>
<li><p>Stage your files to bring those changes from your working directory to the staging area.</p></li>
<li><p>Commit your files to bring the changes from the staging area to the git repository.</p></li>
</ul>


<p>Your workflow will be something like this:</p>

<ol>
<li>Modify files in your working directory.</li>
<li>Stage the files.  This adds snapshots of them to the staging area.</li>
<li>Commit your changes.  This takes the files as they are in the staging area and stores that snapshot in your git repository.</li>
</ol>


<h2>Getting started with Git</h2>

<p>To install and setup Git, go here and follow the very good instructions.</p>

<ul>
<li><a href="http://git-scm.com/book/en/Getting-Started-Installing-Git">http://git-scm.com/book/en/Getting-Started-Installing-Git</a></li>
<li><a href="http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup">http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup</a></li>
</ul>


<p>I highly recommend the entire <a href="http://git-scm.com/documentation">http://git-scm.com/documentation</a> site
And for a more thorough explanation of Git, what it is, and how it works, I particularly recomment this chapter <a href="http://git-scm.com/book/en/Getting-Started-Git-Basics.">http://git-scm.com/book/en/Getting-Started-Git-Basics.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My personal Git command reference]]></title>
    <link href="http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/my-personal-git-command-reference/"/>
    <updated>2013-12-06T18:47:42-08:00</updated>
    <id>http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/my-personal-git-command-reference</id>
    <content type="html"><![CDATA[<h2>Set up the repository for your new project</h2>

<p>Brand new project.  Start in the project directory.  Then:</p>

<pre>
  $ git init
</pre>


<p>How is git looking (you will find some useful guidance printed out with this command too):
  $ git status</p>

<p>Ready to stage your commits?  Here is the long way:
  $ git add .
  $ git commit -m &ldquo;Initial commit&rdquo;</p>

<p>Here is a useful short way:
  $ git commit -am &ldquo;Initial commit&rdquo;</p>

<p>Point to a new repo on github.  Note: Must create this new repo on github first!
  $ git remote add origin <a href="https://github.com/">https://github.com/</a><username>/demo_app.git</p>

<p>Which remote repositories are being pointed to:
  $ git remote -v</p>

<p>List remote and local branches:
  $ git branch -a</p>

<p>Push to github:
  $ git push -u origin master</p>

<p>First push to heroku:
  $ heroku create
  $ git push heroku master
  $ heroku run rake db:migrate</p>

<p>Further pushes to heroku
  $ git push heroku master</p>

<h2>create a new local repo</h2>

<h2>create a new github repo</h2>

<h2>checking in (locally)</h2>

<h2>pushing to github</h2>

<h2>pulling, when and why</h2>

<h2>branching</h2>

<h2>merging</h2>

<h1>Advanced</h1>

<p>Show the last 3 commits:
  $ git log &mdash;oneline</p>

<p>Want to get the new stuff from master into your branch, but before your commited changes?  Do
this.  First switch to the branch &lsquo;unicorns&rsquo;
  $ git checkout unicorns</p>

<p>  $ git rebase master</p>

<p>In the middle of some work on another branch and have to interrupt and get back to the master
for some reason?  Do this.  First see what you are working on
  $ git diff</p>

<p>Save working directory and index state WIP on my_branch: b2bdead Add dogs.  And restores last
commit.
  $ git stash save</p>

<p>Now these return nothing
  $ git diff
  $ git status</p>

<p>Now get back to master and update:
  $ git checkout master
  $ git pull</p>

<p>When done, get back to our stashed work:
  $ git checkout my_branch
  $ git stash apply</p>

<p>Verify we are in the same place:
  $ git diff</p>

<p>  $ git stash list
  $ git stash apply stash@{1}
  $ git stash drop</p>

<h1>Branching, this scares me&hellip;</h1>

<p>First, create the branch locally.  This automatically changes you to this branch locally.
  $ git checkout -b new_branch_name</p>

<p>To check this into github, do this and the new branch will automatically get created on github,
then your code will get pushed into that branch.
  $ git push origin new_branch_name</p>

<p>Also very useful are these links:
<a href="http://www.ndpsoftware.com/git-cheatsheet.html#loc=workspace;">http://www.ndpsoftware.com/git-cheatsheet.html#loc=workspace;</a>
<a href="http://git-scm.com/book">http://git-scm.com/book</a></p>

<p>Use this to confirm WHICH branch you are on.
  $ git branch
  $ git add .
  $ git commit -m &ldquo;a good commit message&rdquo;
  $ git push origin new_branch_name</p>

<p>Very important tips for switching between branches.  ALWAYS commit your changes to your current
branch before changing branches.  I assumed the files would stay in the old branch as I switched
to the new branch, but NO.  The changes will follow you around like a lost puppy until you commit
them.</p>

<p>Ok, I&rsquo;ve got this branch (or worse, several branches).  I&rsquo;m done working on them.  They are all checked in, as branches.  But now, I need to get the master branch back up to date.  How do I do this with FIVE branches.  Don&rsquo;t panic, we can do this thing.  First, make sure everything is up to date and checked in.  For me, everything is check in locally and remotely.
  $ git status</p>

<p>Then, get onto the master branch.
  $ git checkout master</p>

<p>Now we are going to merge each branch in, push it to github, and then delete the branch since we are done with them.  Skip the last step if you aren&rsquo;t quite done with the branch.
  $ git merge chapter_2
  $ git push origin master    (also can just usually say &lsquo;git push&rsquo; here)
  $ git branch -d chapter_2</p>

<p>  $ git merge chapter_3
  $ git push
  $ git branch -d chapter_3
Repeat until you&rsquo;ve merged in each branch.  Yeay!  This worked for me and I saw what I wanted on github.  I have both the branches I expect as well as each branch merge present as a commit on the master.  Excellent!  Git is starting to be a Very useful tool instead of an occasional impediment.  :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My favorite unix commands]]></title>
    <link href="http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/my-favorite-unix-commands/"/>
    <updated>2013-12-06T16:03:22-08:00</updated>
    <id>http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/my-favorite-unix-commands</id>
    <content type="html"><![CDATA[<pre>
type (for when where doesn't tell me what I want)

tree
</pre>


<p>erase line</p>

<pre>
[ctrl] + u
</pre>


<p>stop program</p>

<pre>
[ctrl] + c
</pre>


<p>no really, stop the danged program</p>

<pre>
[ctrl] + d
</pre>




<pre>
ps
ps -ef
ps -x
ps -a
</pre>


<p>different for different systems, I&rsquo;ve found over the years of using different unix systems.</p>

<pre>
kill _process_id_

</pre>


<pre>
~ for my own directory
. for here
.. for one directory above
</pre>


<p>print working directory</p>

<pre>
pwd 
</pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I like VI]]></title>
    <link href="http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/why-i-like-vi/"/>
    <updated>2013-12-06T13:08:54-08:00</updated>
    <id>http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/why-i-like-vi</id>
    <content type="html"><![CDATA[<h2>What is VI</h2>

<p>VI is a powerful, but brutal, command line text editor available on all unix-based systems.</p>

<p>I discovered VI while at university studying for my computer engineering degree.  The joke at the time was that VI is &lsquo;user VIolent&rsquo;.  It is hard to deny this perspective, especially as I share it.  After my first couple of stumblings into inadvertant launchings of vi, my unix mentor sat down with me a first taught me how to get the heck out of there, and then taught me how to leverage it to my own benefit.</p>

<p>The biggest benefits to me are:
1. The ease with which I can jump around my document by line/word/page.
2. The ability to copy/paste/delete my chosen number of words or lines.</p>

<p>For any quick little documents I need to write, I am usually happiest in vi.</p>

<h2>Command mode vs Insert mode</h2>

<p>Vi has two modes of operation.  Command mode and Insert mode.  Command mode takes commands which cause action to be taken on the file you are working on.  Insert mode is where entered text is inserted into the file.</p>

<h4>Command mode</h4>

<ul>
<li>In the command mode, every character typed is a command that does something to the text file being edited; a character typed in the command mode may even cause the vi editor to enter the insert mode.</li>
</ul>


<h4>Insert mode</h4>

<ul>
<li>In the insert mode, every character typed is added to the text in the   file; pressing the &lt;Esc> (Escape) key turns off the Insert mode.</li>
</ul>


<h2>Commands</h2>

<h4>Starting/exiting vi</h4>

<p>How to get into vi in the first place.  From your command line:</p>

<pre>
vi your_filename
</pre>


<p>To exit vi and save changes:</p>

<pre>
:wq
</pre>


<p>To exit vi without saving changes:</p>

<pre>
:q!
</pre>


<p>And most importantly, to enter vi command mode:</p>

<pre>
[esc]
</pre>


<p>The commands can be broken into a several categories.</p>

<h4>Cursor movement</h4>

<h4>Screen movement</h4>

<h4>Alter text</h4>

<h6>Insert or add text</h6>

<h6>Change text</h6>

<h6>Delete text</h6>

<h2>Search</h2>

<h2>File input/output</h2>

<h2>Miscellaneous</h2>

<br>


<hr />

<h3>NOTE</h3>

<p>Both UNIX and vi are case-sensitive. Be sure not to use a capital letter in place of a lowercase letter; the results will not be what you expect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How the unix .alias file can make your command line life better]]></title>
    <link href="http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/unix-alias-file/"/>
    <updated>2013-12-06T12:50:52-08:00</updated>
    <id>http://sprestage-tech-blog.herokuapp.com/blog/2013/12/06/unix-alias-file</id>
    <content type="html"><![CDATA[<h2>Intro to .alias</h2>

<p>Why use command aliases in unix.</p>

<h2>How to implement</h2>

<p>Command aliases in unix.</p>

<h4>location</h4>

<pre><code>- where to location of the alias file 
- what is the alias file called 
</code></pre>

<h4>sourcing</h4>

<pre><code>- how to source it manually and automatically
</code></pre>

<h2>Favorite shortcuts</h2>

<pre><code>- talk about my 10 favorite shortcuts
    va
    sc
    la
    l
    cf
    h
    ls
    a
    rm -i
</code></pre>

<h2>Remembering new commands</h2>

<pre><code>- also a good way of noting down commands you just learned and want to use much more, and want to get the syntax down before you forget
</code></pre>

<h2>Protect from unfortunate commands</h2>
]]></content>
  </entry>
  
</feed>
